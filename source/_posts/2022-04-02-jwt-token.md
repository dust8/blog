---
title: jwt token 自动刷新
date: 2022-04-02 06:15:31
tags:
  - jwt
  - token
---

jwt 可以有 2 类 token, 一类叫`ACCESS_TOKEN`用来请求接口, 一类叫`REFRESH_TOKEN`用来刷新`ACCESS_TOKEN`. `ACCESS_TOKEN` 时间比较短, 例如 10 分钟,`REFRESH_TOKEN` 比较久比如 7 天, 这样就可以保证 7 天内保持登录.
还有个参数`ROTATE_REFRESH_TOKENS`, 当刷新`ACCESS_TOKEN`时`REFRESH_TOKEN`也刷新,
这样可以一直保持登录,除非在`REFRESH_TOKEN` 时间内都没刷新.

## 后端

```python
from datetime import timedelta

SIMPLE_JWT = {
    "ACCESS_TOKEN_LIFETIME": timedelta(minutes=30),
    "REFRESH_TOKEN_LIFETIME": timedelta(days=7),
    'ROTATE_REFRESH_TOKENS': True, #
}
```

## 前端

封装 fetch 来处理发送 token, 刷新 token. 里面用了 `chrome.storage` 是浏览器扩展的接口, 自己用户换成 `localStorage` 就可以了

```js
# api.js
import { baseUrl, http } from "./utils/fetchInstance.js";

async function login(data) {
  return http(baseUrl + "/api/token/", {
    method: "POST",
    body: data,
  });
}

export { login };
```

```js
# utils/fetchInstance.js
let baseUrl = "http://127.0.0.1:8000";
let refreshTokenUrl = baseUrl + "/api/token/refresh/";
let isRefreshing = false; // 用于拦截鉴权失败的请求
let TOKEN_KEY = "token";

let getToken = async function () {
  // 避免重复发起刷新
  if (isRefreshing) return;

  let items = await chrome.storage.local.get(TOKEN_KEY);
  if (items[TOKEN_KEY]) {
    items = items[TOKEN_KEY];
  } else {
    items = null;
  }
  return items;
};

let setToken = function (value) {
  console.log("setToken:", value);
  chrome.storage.local.set({ token: value });
};

let clearToken = function () {
  chrome.storage.local.clear();
};

let refreshToken = async (authTokens) => {
  isRefreshing = true;
  try {
    let init = {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({ refresh: authTokens.refresh }),
    };
    let response = await fetch(refreshTokenUrl, init);
    let data = await response.json();
    if (response.ok) {
      await setToken(data);
    } else {
      clearToken();
    }

    isRefreshing = false;
    return data;
  } catch (error) {
    isRefreshing = false;
    return null;
  }
};

async function checkStatus(response) {
  if (response.ok) {
    return response;
  } else {
    if (response.status === 401) {
      let authTokens = await getToken();
      if (authTokens) {
        await refreshToken(authTokens);
      }
    }
    return Promise.reject(response);
  }
}

function parseJSON(response) {
  return response.json();
}

async function http(url, option = {}) {
  let headers = {
    "Content-Type": "application/json",
  };

  option.headers = option.headers || headers;
  option.mode = option.mode || "cors";

  let authTokens = await getToken();
  if (authTokens) {
    option.headers["Authorization"] = `Bearer ${authTokens?.access}`;
  }

  option.method = (option.method || "get").toLocaleLowerCase();
  if (
    option.method === "post" ||
    option.method === "put" ||
    option.method === "delete"
  ) {
    // 非get类请求传参时，需要将参数挂在body上
    option.body = JSON.stringify(option.body);
  }

  return fetch(url, option)
    .then(checkStatus)
    .then(parseJSON)
    .then((data) => data);
}

export { baseUrl, http };

```
